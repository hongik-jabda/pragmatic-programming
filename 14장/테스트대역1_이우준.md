# 14장 테스트 대역
- 테스트 대역이란, 오롯이 테스트를 위해 만들어진 가짜 객체나 컴포넌트
- '굳이 테스트하는 데 실제 객체를 사용해야 하나?'
```
public class UserService{
}
```
- 회원가입 후 가입 인증이 되면 인증 메일을 보냄.
- 테스트하다가 실제 메일 보내버려?
-	 이때 **대역**을 만들고 이 컴포넌트를 통해 테스트 진행.
-	 API 호출 없이도 테스트 가능!
- 물론 실제 코드의 성능과 품질 문제를 완벽히 검증하지는 못함.
-	 하지만 복잡한 시스템의 테스트 환경을 예측 가능하도록 함!!
-	 **밸런스**를 잘 맞춰야 한다.

## 14.1 Dummy
Dummy는 아무런 동작을 하지 않아요.
``` 
public class SomethingFilter extends GenericFilterBean {
	@Override
	public void doFilter(
		ServletRequeist servletRequest,
		ServletResponse servletResponse
		FilterChain filterChain) throws IOExcpetion,ServletException {     // filterChain이 매개변수로 의무적으로.

		// text를 요청하는 request라면 응답의 Content-Type을 "text/plain"으로 만듭니다.
		if (servletRequest.getAttribute("giveMe").equals("text")) {
			servletResponse.setContentType("text/plain");
		}

		// 책임 연쇄 패턴에 따라 다음 필터를 실행하기 위해 필터 체인의 doFilter를 호출합니다.
		filterChain.doFilter(servletRequest, servletResponse);
	}
}
```
- 여기서 filterChain은 doFilter 메서드의 맨 마지막 filterChain.doFilter 코드를 실행하기 위해 존재할 뿐, 우리는 관심이 없음.
```
public class SomethingFilterTest {
	@Test
	public void 요청에_text로_달라는_요청이_있으면_응답의_콘텐츠_타입은_Text_plain이다()
	throws ServletException,IOExcpetion {
	// given
	ServletRequest servletRequest = new MockHttpServletRequest();
	ServletRequest.setAttribute("giveMe", "text");
	ServletRequest servletResponse = new MockHttpServletResponse();

	// when
	SomethingFilter somethingFilter = new SomethingFilter();
	somethingFilter.doFilter(
		servletRequest,
		servletResponse,
		new FilterChain() {   // 마지막 filterchain 값에 ㅏ무런 동작을 하지 않는 익명 클래스가 들어가도록.
			@Override
			public void doFilter(ServletRequest req, ServletResponse res) {
				//do nothing!!!!!!!!!
			}
		});
	
	//then
	assertThat(servletResponse.getContentType()).isEqualTo("text/plain");
	}
}
```

## 14.2 Stub
사본. 미리 준비된 값을 반환하는 대역 객체.
- 결과가 뻔한 것에 비해 동작이 지나치게 복잡한 경우?
```
[요청]
GET https://another-server/ping

[응답]
status: 200
body: {
	''content'': ''pong''
}
```
- 간단한 코드에 비해 API 호출은 매우 큰 cost.
- 이외에도 JPA 같은 저장소에서 findById를 이용해 값을 불러오는 상황
-   저장소에서 데이터를 불러오는 작업은 고연산 작업이지만, 그 결과는 쉽게 예측 가능(지금 불러오는 걸 테스트하려는 게 아님)
- 이때 Stub을 사용해 미리 준비된 값을 반환하면 테스트 가능!
```
class StubExistUserRepository implements UserRepository {
	public Optional<User> findByEmail(String email) {
		return Optional.of(User.builder()
			.id(1L)
			.email(email)
			.nickname("foobar")
			.status(UserStatus.ACTIVE)
			.verificationCode("aaaaaaaaaaaa")
			.build();
	}
	public User save(User user) {
		return User.builder()
			.id(1L)
			.email(user.getEmail())
			.nickname(user.getNickname())
			.status(user.getStatus())
			.verificationCode(user.getVerificationCode())
			.build();
	}
}
```
```
class StubEmptyUserRepository implement UserRepository {
	public Optional<User> findByEmail(String email) {
		return Optional.empty();
	}
	public User save(User user) {}
}
```
- 외부 시스템과 협업하는 상황에서 테스트 코드 작성할 때도 유용.
-	외부 시스템의 API 호출 결과를 받아서 처리해야 할 때, API가 개발 완료될 때까지 마냥 기다릴 순 없자나
-	합의된 내용을 바탕으로 Stub 객체 생성
- Mockito를 사용하면 Stub을 더 쉽게 만들 수 있고 세부적인 동작 지정도 가능하다. 하지만 이 책에선 순수 자바 코드로 구현하려 했다.

## 14.3 Fake
Fake는 테스트를 위한 자체적인 논리를 가지고 있다.
-  최대한 간결하고 보자마자 이해 가능한 테스트를 위해 필요.
-	 Stub는 테스트의 목적을 다소 가리는 느낌이 있음.
```
// UserRepository의 대역(를 구현). 데이터 저장을 위한 간단한 메모리 변수를 갖고 있다.
public class FakeUserRepository implements UserRepository {
	private final long autoGeneratedId = 0;
	private final List<User> data = new ArrayList<>();     // save 메서드 호출시 user data 저장

	@Override
	public Optional<User> findByEmail(long id) {      // id값을 이용해 사용자를 리스트에서 검색 후 불러옴
		return data.stream().filter(item -> item.getId().equals(id)).findAny();
	}

	@Override
	public User save(User user) {    // 사용자 create or update. JPA 동작 따라함.
		if (user.getId() == null || user.getId() == 0) {	// 새로운 사용자일 때(id가 저장되어 있지 않을때)
 			// create 동작
			User newUser = User.builder()
				.id(++autoGeneratedId)
				.email(user.getEmail())
				.nickname(user.getNickname())
				.address(user.getAddress())
				verifiicationCode(user.getVerificationCode())
				.status(user.getStatus())
				.lastLoginAt(user.getLastLoginAt())
				.build();
			data.add(newUser);
			return newUser;
		} else {
			//update 동작
			data.removeIf(item -> item.getId() == user.getId());
			data.add(user);
			return user;
		}
	}
}
```
- 이런 식으로 JPA 없이도 메모리 내에서 저장하고 실행할 수 있도록 하고, 단위 테스트 코드를 작성해보면.
```
@Test
public void 중복된_이메일_회원가입_요청이_오면_에러가_발생한다() {
	// given
	UserCreateDto userCreateDto = UserCreateDto.builder()
		.email("foobar@localhost.com")      // 중복된 이메일 예외 발생을 위해 미리 사용자 만듦
		.nickname("foobar")
		.build();

	UserRepository userRepository = new FakeUserRepository();   // 테스트 목적의 가짜 저장소
	userRepository.save(User.builder(     // 중복된 이메일로 가입 요청
		.id(1L)
		.email("foobar@localhost.com")
		.nickname("foobar")
		.status(UserStatus.ACTIVE)
		.verificationCode("aaaaaaaaaaaa")
		.build())

	//then
	assertThrows(DuplicatedEmailException.class,() -> {     // 예외가 발생하는지 테스트
		//when
		UserService userService = UserService.builder(
			.verificationEmailSender(new DummyVerificationEmailSender())
			.userRepository(userRepositiory
			.build(;
		User user = userRepository.register(userCreateDto);
	});
}
```
- 로컬 환경에서 개발할 때는 Fake 저장소를 이용하도록 할 수도.
-	매번 데이터베이스와 연동하지 않고도 서버를 구동시킬 수 있으므로 편리!
