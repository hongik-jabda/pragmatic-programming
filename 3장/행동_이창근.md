# 3.0 자동차 클래스를 만들어주세요.

### A 개발자
```java
public class Car {

    private Frame frame;
    private Engine engine;
    private float maxSpeed;
    ...
}
```

### B 개발자
```java
public class Car {

    public void drive() {}
    public void changeDirection() {}
    public void stop() {}
    ...
}
```

데이터 위주로 짜여진 A개발자의 코드는 객채지향적이지 않다. 데이터 덩어리이며, 객체보다는 구조체에 가깝다. B개발자의 코드는 객체지향적이다. 여기서 다시 객체지향의 가벼운 정의를 알아가보면 좋다.

> **객체지향은 어떠한 역할을 수행하기 위해 책임을 다하는 객체들이 서로 협력하는 공동체이다.**

-> 서로 협력하기 위해서는 무엇이 중요할까?
- private으로 감싸진 데이터들과 getter, setter 뭉치?
- public으로 공개된 '난 이런 행동을 해'라고 외치는 클래스?

이제 행동이 객체지향에서 얼마나 중요한지 이해된다.

# 3.1 덕 타이핑

> **만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.**

즉, **행동이 같다면 같은 객체이다.** 란 뜻이다. 그만큼 객체에게 있어 행동이 중요하며, 행동이 역할을 정의하고, 역할이 곧 객체를 정의하는 것이다.

### 잠깐만! 역할? 행동? 책임? 협력? 무슨 말이야?

- **협력(collaboration)** : 궁극적인 목표를 달성하기 위해 객체들이 수행하는 **상호작용**
- **책임(responsibility)** : 객체들이 협력에 참여하며 **수행하는 행동**들, 아는 것과 하는 것으로 나뉜다.
  - 아는 것 : 정보에 대해 아는 것, 관련된 객체에 대해 아는 것, 계산할 수 있는 것
  - 하는 것 : 객체를 생성하거나, 계산을 수행하는 것, 다른 객체의 행동을 시작하는 것
- **역할(role)** : 협력 안에서 수행하는 **책임의 집합**, 다른 책임으로 교체할 수 있는 책임들의 집합이다. 인터페이스를 떠올리면 된다.

즉, 덕 타이핑에서 얻을 수 있는 교훈은 - 객체를 정의하고 식별하는 것은 책임이지, 데이터가 아니라는 것이다. 우리가 궁금한 것은 객체가 뭘 가지고 있는지가 아니라, 객체가 뭘 할 수 있는지 이다.

# 3.2 행동과 구현

설계를 하며 행동에 대해 고민하다보면 자연스레 구현에 대한 생각으로 빠지기 쉽다.
- 오리처럼 걸으려면 1초에 몇번 걸어야 하지?
- 오리처럼 헤엄치려면 얼마나 빨리 헤엄쳐야 하지? 발은 어떻게 생겼지?
- 오리처럼 꽥꽥거리다가 지치면 안되니까 최대 10번까지만 가능하도록 해야하나?

어쩔 수 없이 구현의 구렁텅이에 빠지기 마련이다. 그래서 객체지향언어들은 각자의 방법으로 이런 사고를 조심스레 교정한다. 자바의 경우에는 **인터페이스**이다.

> **인터페이스는 계약이다.**

인터페이스는 구현을 가질 수 없으며, 그 자체로 완성된 코드이다. 실제로 무슨 행동을 하는지에만 집중할 수 있도록 도와주는 좋은 방법이다.

또한 인터페이스를 통해 개발자간의 협력도 좋아진다. 인터페이스만 같이 정의하고 나면, 각 인터페이스의 구현체를 잘 개발해오는 방식으로 협력할 수도 있다.

# 3.3 인터페이스

> **인터페이스와 행동은 다르다.**

인터페이스와 행동은 살짝 다르다. 인터페이스는 사실 설명서이다. 이 객체를 사용하려면 이런 메시지를 보내어 사용하라! 라는 설명을 제공하는 방법이다.

예를 들어, 어떤 객체를 사용할 때(메서드를 호출할 때) 우리는 int a = SampleObject.count(13) 과 같은 방법으로 한다. 이렇게 행동의 시그니처와 보내야 하는 값, 받는 값들의 정의된 것이 인터페이스이다.

객체들이 서로 협력을 위해 메시지를 주고받고, 행동을 지시하고, 가끔은 물어보는 것들의 방식을 정의하는 것이 인터페이스이다.

# 3.4 행동과 역할

행동위주의 사고를 한다면 객체를 설계하며 다음과 같은 의문이 계속해서 들어야 한다.
- 이 객체는 어떤 행동을 하는 객체인가?
- 이 객체의 목표(역할)은 무엇인가?
- 이 객체는 어떤 역할들과 상호작용해야 하는가?

즉, 가장 처음에 우리는 자동차를 만들었는데, 자동차를 만든다는 것은 이 3가지 의문을 해소하지 못한다. 우리는 이런 의문을 가져야 했다.
- 자동차는 어떤 행동들을 하는가?
- 자동차는 어떤 역할을 수행해야 하는가?
- 자동차는 어떤 역할들과 상호작용해야 하는가?

그리고 깨닫는다. 우리는 사실 자동차를 만들고 싶었던게 아니라, **사람을 태우고 달릴 수 있는 객체**를 만들고 싶었다는 사실을! 그렇게 사고하면 자연스레 이런 결과물이 나온다.
```java
public interface Vehicle {

    public void board() {}
    public void ride() {}
    ...
}
```
이것이 우리가 만들고자 했던 객체의 전부다.

# 3.5 메서드

메서드와 함수에 대해서 들어보았을 것이다. 그리고 이 둘을 거의 동의어처럼 사용한다. 하지만 함수와 메서드는 다르다.

우리는 인터페이스를 통해 설명서를 받고, 메시지를 보낸다. **여기서 메시지를 보낸다는 것은 객체가 아니라 특정 역할이 작동하도록 지시하는 것이다.** 우리는 Car인지 Bicycle인지 궁금하지 않다. Vehicle 역할에게 달리라고 지시할 뿐이다. 여기서 함수와 메서드의 차이가 발생한다.
- 함수는 정해진 행동이다. 같은 메시지에 대해서 같은 객체가 같은 행동을 하여 같은 결과가 나온다.
- 메서드는 메시지를 보내는 것이다. 이런 것들을 보내줄테니 알아서 처리해서 결과를 달라는 것이다. 명령보다는 신뢰이다. 그 과정은 중요치 않다. **중요한 것은 내가 해당 역할에게 메시지를 보낸다는 그 협력 자체가 중요한 것이다.** 그렇기 때문에 구현이 중요하지 않은 것이다.