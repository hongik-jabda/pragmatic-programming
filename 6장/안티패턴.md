# 안티패턴

---

- 별로 좋지 않은 안티패턴에 대해 살펴보자.

### 스마트 UI(Component)

- 에릭 에반스의 <도메인 주도 설계>에서 소개
- 특징
    - 스마트 UI는 데이터 입출력을 UI 레벨에서 처리
    - 비즈니스 로직도 UI 레벨에서 처리
    - DB와 통신하는 코드도 UI 레벨에서 처리
- 여기서 말하는 UI는 프론트(GUI)의 UI가 아니라 백엔드의 API
- Controller는 API를 만드는 컴포넌트
- 따라서 Controller는 스프링에서 UI를 만드는 도구이다.
- 코드 6.1 을 보자 Controller에서 모조리 다하고 있음.
- 따라서 Controller에 과중한 책임이 몰려있다. 이쓰 과로사 각.
- Controller는 사용자의 입출력을 받고 어떤 비즈니스 로직을 실행할지 결정하는 역할만 해야함.
- Controller의 가장 큰 역할은 엔드포인트를 정의하고 API 사용자의 요청을 받아 그 결과를 응답 포맷에 맞춰 반환하는 것입니다.

- 장점
    - 생산성이 빠르다.
    - 이해하기 쉽다.
    - MVP(Minimum Viable Product) 만들 때 유용

### 양방향 레이어드 아키텍처

- layered architecture를 지향하는 프로젝트에서 많이 발생
- 레이어드 아키텍처에서 정의한 레이어들의 의존관계에 양방향 의존이 발생하는 경우를 칭함.
- 레이어드 아키텍처란????
- 애플리케이션 레이어
    - 프레젠테이션 레이어
        - 사용자와의 상호작용 처리, 결과 표시
    - 비즈니스 레이어
        - 애플리케이션의 비즈니스 로직을 처리하는 역할
    - 인프라스트럭쳐 레이어
        - 외부시스템(DB)과의 상호작용
- 장점
    - 단순하고 직관적인 구조
- 레이어드 아키텍처의 기본원칙
    - 레이어 간 의존 방향은 단방향을 유지
    - 코드 6.3에 주목한다면 PostCreateRequest 가 API 레이어에서 비즈니스레이어로 전달되는 범죄현장을 목격할 수 있다.
- 이것이 무너지면 양방향 레이어드 아키텍처
    - 레이어 역할의 의미가 없어짐.
    - 양방향 참조과 생기게 된다면 하나의 레이어로 레이어를 나눈의미가 없어짐.

### 해결법

1. **레이어 별 모델 구성**
    - 레이어별로 모델을 따로 만든다.
    - 코드6.3을 예시로는 PostCreateRequest가 아닌 PostCreateCommand 모델을 따로 만든다.
    - 이를 API의 모델과 구분하기 위해서 명명규칙을 만들어 준다. ex) API 레이어에는 Reqeust, 비즈니스 레이어에는 Command 를 클래스 뒤에 붙임.
    - 이러한 방식은 각각의 레이어에서 사용하는 DTO를 분리할 수 있게 됐다
        - 따라서 보안에도 좋다.
        - 이 부분 뭔말인지 논의가 필요해보임.
        - Post CreateCommand 클래스에 필요한 정보를 꼭 PostCreateRequest 클래스에서만 가져올 필요가 없다.
        - 요것은 객체 역할의 분리
    - 단점
        - 코드 양 늘어남.

1. **공통 모듈 구성**
    - 공통으로 참조하는 코드를 별도의 모듈로 분리
    - 모든 레이어가 단방향으로 참조하는 공통 모듈을 만들고, PostCreateReqeust클래스 같은 모델을 배치
    - 그림 6.5처럼
    - but 야 그거는 그냥 회피성향 한거잖아!
    - core 모듈이 레이어니?
    - core 모듈이 레이어라면 모든 레이어가 바라보는 레이어를 두는 것이 괜찮나요?
    - 나중에 설명할게!

### 완화된 레이어드 아키텍처

- 안티패턴!
- 스마트 UI랑 같은 이유

### 트랜잭션 스크립트

- 스마트 UI를 할 때 ‘모든 API는 어떤 스크립트를 실행하고 응답하는 수준의 역할만 한다’의 연장선
- 비즈니스 레이어에 위치하는 서비스 컴포넌트에서 발생하는 안티패턴
- 서비스 컴포넌트 구현이 어떤 ‘트랜잭션이 걸려있는 스크립트’를 실행하는 것처럼 보일 때를 말함.
- 코드 6.6 을 보면 단순히 controlelr의 코드를 서비스의 코드로 옮겼다. + @Transactinal이 추가됨.
- 이런게 트랜잭션 스크립트
- 일명 Smart Service
- 단순히 생각하면 비즈니스 로직이 서비스 컴포넌트에 있는 것이 맞아보임
- 서비스 컴포넌트는 비즈니스 레이어에 위치하는 컴포넌트고 비즈니스 레이어는 비즈니스 로직이 있는 공간이기 때문
- but 반은 맞고 반은 틀림
- 아니 그러면 어떻게 하라는 거에요~~@!!!!
- 비즈니스 로직은 도메인 모델에 위치해야함. ex) 앞에서 보았던 객체의 메서드
- 개발자가 트랜잭션 스크립트같은 코드가 나오는 이유는 서비스는 비즈니스 로직을 처리하는 곳이라고 생각해서 그럼.
