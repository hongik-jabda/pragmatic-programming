> **도메인** : 
애플리케이션이 해결하고자 하는 문제 영역
> 

## 10.1 소프트웨어 개발의 시작

소프트웨어 도메인에 대해 논하기 전에, **사업가 입장에서 소프트웨어 시스템을 만들게 되는 계기**를 먼저 이해해보자.

일반적으로 비즈니스는 **‘소프트웨어를 만들어야겠다’** 라는 전제로 시작되지 않는다. 비즈니스는 **사용자가 겪는 문제를 해결**하는 것이 목적이며, 소프트웨어는 그 해결책 중 하나로 선택되는 수단일 뿐이다.

### 비즈니스와 문제 영역

오늘날 대부분의 사업은 **고객의 문제**에서 출발한다. 고객이 겪는 문제를 파악하고, 요구사항을 분석하여 이를 기반으로 **솔루션**을 개발한다. 이 솔루션은 **하드웨어**일 수도 있고 **소프트웨어**일 수도 있다.

### 개발자와 도메인

개발자가 소프트웨어를 개발하는 단계에서는 이미 **목표하는 고객**과 **고객이 겪는 문제 상황**이 정의되어 있는 경우가 많다. 이는 문제 정의가 선행되고, 그에 대한 해결책으로서 소프트웨어가 개발되기 때문이다.

### 도메인의 정의

사용자가 겪는 문제 영역이 바로 **도메인**이다. 그리고 문제 영역이 곧 **비즈니스 영역**이므로, 도메인은 **비즈니스 영역**을 의미하기도 한다. 따라서 **도메인은 문제 영역이자 비즈니스 영역**이다.

### 개발자의 역할

개발자의 역할은 단순히 요구사항에 맞는 애플리케이션을 개발하는 것이 아니다. 고객이 겪는 문제 상황을 **소프트웨어로 해결**해 주는 역할을 한다. 즉, 개발자는 **도메인을 분석**하고, 고객의 문제를 인지하여 이에 맞는 도메인 솔루션을 개발하는 사람이다.

개발자는 단순히 **개발 기술**만 잘해서는 좋은 개발자가 될 수 없다. 우리가 개발해야 하는 것은 단순한 애플리케이션이 아니라 **‘도메인’ 어플리케이션**이다. 도메인을 제대로 이해하지 못하면 소프트웨어의 품질은 낮아질 수밖에 없다. 즉, 도메인의 특성과 요구사항을 이해하지 못한 소프트웨어는 **무용지물**이 될 가능성이 크다.

## 10.2 애플리케이션의 본질

> 우리는 **‘도메인’** 어플리케이션을 개발한다!
> 

개발자는 **‘도메인’ 개발자**로서, 자신을 단순히 ‘스프링 개발자’라고 소개하는 것은 바람직하지 않다.

- ❌ 스프링 개발자
- 🙆‍♂️ 스프링을 잘 다루는 개발자, 스프링 전문가

앞서 이야기한 것처럼 **스프링**이나 **JPA** 같은 프레임워크는 애플리케이션의 핵심이 아니다. **애플리케이션의 본질**은 **도메인**이다. 스프링과 JPA는 그저 **도메인 문제를 해결하기 위한 수단**에 불과하다.

그렇다면 스프링과 JPA는 왜 애플리케이션의 본질이 될 수 없을까?

### 프레임워크에 의존하는 잘못된 접근

👩 🗯️ 신규 프로젝트를 만들어주세요!

많은 개발자가 아래와 같은 생각을 먼저 한다.

- API 서버를 만들어야 하니 스프링 웹 설정해야지
- 인증은 JWT 사용할거니까 기존에 사용하던 인증 코드 미리 옮겨둬야지
- JPA나 QueryDSL 사용할테니 관련 의존성 설정해야겠다
- 테스트를 위한 H2 데이터베이스 설정해야지

이러한 접근은 **레이어드 아키텍처**의 하향식 접근 방식이며, 주로 **프레젠테이션 레이어**나 **인프라스트럭처 레이어**를 먼저 생각하는 것이다. 그러나 이는 바람직하지 않다. 이러한 결정들에는 **특정 기술을 사용할 것이라는 가정**이 이미 포함되어 있다. 

😆 : 스프링 사용해야지, 웹 서버 만들어야징, JPA 사용해야지, RDB 사용해야지, JWT 사용해야지, 인증 넣어야지~

**근데 아직 도메인 분석 끝나지도 않았음 !!** 

**“신규 프로젝트를 만들어 주세여”** 라는 질문만 봐서는 무슨 프로젝트를 만들고 싶고 도메인이 무엇이지 전혀 알 수 없다. 따라서 이 질문의 정답은 **“그래서 도메인이 뭔데?”** 🤷‍♂️ 와 같은 역질문을 하는 것이다. 

**도메인의 요구사항**을 먼저 정리한 후, 시스템의 설계와 세부 구현은 도메인 분석을 바탕으로 선택되어야 한다.

### 도메인 중심의 설계

스프링이나 JPA 같은 프레임워크를 전제로 한 설계를 피해야 한다. 이러한 결정을 미리 내려버리면 프로젝트는 결국 해당 프레임워크에 **의존적인 형태**가 될 수밖에 없다.

결과적으로, 프로젝트가 **프레임워크 없이 설명되지 못하는 상황**이 발생해서는 안 된다.

다시 말해, 결과물을 돌이켜봤을 때 다음과 같은 반응이 나오면 안된다.

👨🏻‍🦱 ”이 프로젝트는 스프링과 JPA를 사용하는 프로젝트구먼.” → ❌

🧑🏻‍🦰 ”이 프로젝트는 이런 도메인을 다루고 있네.” → 🙆🏼‍♀️

### 도메인을 설명하는 아키텍처

**프로젝트 설계**는 도메인을 설명할 수 있어야 한다. **아키텍처**만 보더라도 어떤 도메인을 다루고 있는지 알 수 있어야 한다.

애플리케이션에서 **도메인을 제외한 다른 부분**은 도메인 문제를 해결하기 위한 **도구**일 뿐이다. 따라서 중요한 것은 **비즈니스 가치를 전달**하는 방식과, 이를 위한 **도메인 분석** 및 **설계**이다.

## 10.3 도메인 모델과 영속성 객체

### 도메인 모델과 JPA 엔티티를 구분해야 하는가?

다시 말해 도메인 모델과 JPA 엔티티는 구분해서 개발해야 하는가에 관한 내용이기도 하다.

우리는 **도메인 모델**과 **영속성 객체**(JPA 엔티티)의 차이점에 대해 이야기했다. 이를 **구분하기 전략**이라 부르며, 도메인 모델과 영속성 객체를 나누어 개발하는 방식이다.

> **구분하기 전략** :
도메인 모델과 영속성 객체를 나누어 관리하는 전략. 예를 들어, 도메인 모델로서의 `Account` 클래스와 데이터베이스 영속화를 담당하는 `AccountJpaEntity` 클래스를 분리한다.
> 

반대로, 두 역할을 하나의 클래스로 통합하는 방식도 있다. 이를 **통합하기 전략**이라 한다.

> **통합하기 전략** :
도메인 모델과 영속성 객체를 하나의 클래스로 통합하여 관리하는 전략. 즉 Account 클래스 하나에 두 객체의 역할이 들어갈 수 있게 한다. 이 전략을 사용하는 프로젝트에서 Account 클래스는 도메인 모델이면서 동시에 영속성 객체이다. JPA를 사용한다면 `@Entity` 애너테이션이 이 클래스에 추가된다.
> 

이번 절에선 구분하기 전략과 통합하기 전략을 알아보고 어떤 전략이 더 나은 전략일지 비교 분석해보자.

다음과 같은 요구사항을 가정해보자 :

- 계정(Account)라는 도메인이 있다.
- 계정은 닉네임을 변경할 수 있어야 한다.
- 계정은 데이터베이스에 저장되고 불러올 수도 있어야 한다.

### 10.3.1 통합하기 전략

통합하기 전략은 도메인 모델과 영속성 객체의 역할을 하나의 클래스에 통합하는 전략이다.

**코드 10.1** 통합하기 전략을 사용해 Account  객체를 표현

```java
@Data
@Entity(name="account")
public class Account {
	@Id
	@GeneratedValue(strategy= = GenerationType.IDENTIFY)
	private Long id;
	
	@Column(unique = true)
	private String email;
	
	@Column
	private String nickmane;
	
	pubilc void changeNickname(String nickname) {
		this.nickname = nickname;
	}
}
```

위 코드의 Account 클래스는 도메인 모델의 요구사항인 닉네임을 변경하는 코드로 구성되고 영속성 객체로서의 역할을 하기 위해 JPA 엔티티로 등록돼 있다.

도메인 모델과 영속성 객체를 통합한 것이다.

이 방식은 다음과 같은 장점을 가진다:

- **코드 중복 감소**: 두 개의 클래스를 만들 필요가 없다.
- **개발 속도 향상**: 관리할 코드가 적어 개발 속도가 빨라진다.
- **ORM의 자연스러운 사용**: ORM의 목적은 객체와 관계형 데이터를 매핑하는 것이므로, 통합하기 전략은 이 흐름에 맞는 선택이다.

단점:

- **책임 혼재**: 도메인 모델에 영속성 관련 코드가 섞여, 클래스의 책임이 모호해진다.
- **데이터베이스 중심 사고**: 도메인 확장보다 데이터베이스 변경을 먼저 생각하게 되는 경향이 있다. 예를 들어 도메인 모델이 확장돼야 할 때 도메인을 어떻게 변경할지보다 데이터베이스 스키마 변경이나 마이그레이션 걱정을 먼저 하게 될 것이다.
- **단일 책임 원칙 위반** : 도메인 모델로서의 역할과 영속성 객체로서의 역할을 통합했기 때문에 단일 책임 원칙을 위반한다.

### 10.3.2 구분하기 전략

구분하기 전략은 도메인 모델과 영속성 객체를 각각 별도의 클래스로 나누는 방식이다.

**코드 10.2** 구분하기 전략을 사용해 도메인 객체를 표현

```java
@Builder
public class Account {
	private Long id;
	private String email;
	private String nickname;
	
	public void changeNickname(String nickname) {
		this.nickname = nickname;
	}
}
```

**코드 10.3** 구분하기 전략을 사용해 영속성 객체를 표현 (코드 8.7과 동일)

```java
@Data
@Entity(name = "account")
public class AccountJpaEntity {

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTIFY)
	private Long id;
	@Column(unique = true)
	private String email;
	@Column
	private String nickname;
	
	public static AccountJpaEntity from(Account account){
		AccountJpaEntity result = new AccountJpaEntity();
		result.id = account.getId();
		result.email = account.getEmail();
		result.nickname = account.getNickname();
		return result;
	}
	
	public Account toModel(){
		return Account.builder()
			.id(this.id)
			.email(this.email)
			.nickname(this.nickname)
			.build();
	}
}
```

구분하기 전략을 사용하면 **ORM을 사용하는 이유가 없지 않냐**는 의문이 있을 수 있다. 맞다, 구분하기 전략은 **ORM에 종속되지 않기** 위해 도메인 모델과 영속성 객체를 분리하는 것이다. 이를 통해 **데이터베이스 접근 방식을 자유롭게 변경**할 수 있으며, **단일 책임 원칙(SRP)****을 준수하여 각 클래스가 명확한 책임을 가진다.

그러나 단점도 있다. **코드 중복**과 **추가 매핑 작업**으로 인해 코드량이 많아지고, ORM의 다양한 혜택을 활용하기 어려워질 수 있다. 이로 인해 **개발 속도가 느려지는** 단점이 발생할 수 있다.

> **changeNickname 메서드는 왜 AccountJpaEntity가 아닌 Account 클래스에 있을까?**
> 
> 
> 이 메서드는 도메인에 요구되는 로직이기 때문에 **도메인 모델인 Account** 클래스에서 처리하는 것이 자연스럽다. 영속성 객체는 데이터 영속화와 관련된 코드만을 가져야 하며, 도메인 로직을 포함하게 되면 영속성 코드 변경이 도메인 로직에 영향을 미칠 수 있다.
> 

### 10.3.3 평가

앞에서 이야기한 내용을 정리하면 다음과 같다.

- **통합하기 전략**
    - 도메인과 영속성 객체를 하나의 클래스로 통합한다.
    - 작성해야 하는 코드의 양이 줄어들어 개발 속도가 빠르다.
    - 도메인이 영속성 라이브러리에 강결합된다.
- **구분하기 전략**
    - 도메인과 영속성 객체를 분리한다.
    - 작성해야 하는 코드의 양이 늘어나지만 유연성이 높아진다.
    - 도메인과 영속성 라이브러리가 분리되어 독립적이다.
    

그러면, 도메인이 영속성 라이브러리에 강결합되는 **통합하기 전략**은 **구분하기 전략**과 비교해 항상 부정적인 결과를 낳을까? → 그렇지 않다!! 

**두 전략 모두 장단점이 있으며 상황에 따라 선택**이 달라진다. 어떤 설계 전략이든 **트레이드오프**가 존재하므로, 프로젝트 요구사항과 상황에 맞는 전략을 선택하는 것이 중요하다.
